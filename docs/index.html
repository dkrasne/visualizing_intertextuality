<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.3">
<title>Visualizing Intertextuality</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-air,wide.d041fa8d.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-air,wide.d041fa8d.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="modulepreload" href="./_observablehq/client.69715e39.js">
<link rel="modulepreload" href="./_observablehq/runtime.e080113b.js">
<link rel="modulepreload" href="./_observablehq/stdlib.ec062f48.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/e780feca.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/72f4716c.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.d20f2cad.js">
<link rel="modulepreload" href="./_npm/@observablehq/plot@0.6.17/d761ef9b.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/9cffc2bd.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/18cbf477.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e93ca09f.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/0f2de24d.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/65eb105b.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/7ef8fb2e.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/aeb57b94.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/1d2aed74.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/5ced1d52.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/9ba9c7f3.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/4202580c.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/cdd7e898.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/b4e2ad9a.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e804d15.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/86074ef6.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/40599fb3.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/e49e792c.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/8d1e5425.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/20d3f133.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/7553081f.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/0dfd751c.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/3c90ee06.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/843b6a76.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/ba24c2e7.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/4d94e5b7.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/6d3a6726.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/9f03c579.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/07c9626f.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/b58a267d.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/004da2ac.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/b5786b3f.js">
<link rel="modulepreload" href="./_npm/interval-tree-1d@1.0.4/53fe8176.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/e08981d9.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/02d43215.js">
<link rel="modulepreload" href="./_npm/binary-search-bounds@2.0.5/cbf6ba23.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/aa00730b.js">
<link rel="icon" href="./_file/observable.1af93621.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.69715e39.js";
import {registerFile} from "./_observablehq/stdlib.ec062f48.js";

registerFile("./data/intxt_network_graph.json", {"name":"./data/intxt_network_graph.json","mimeType":"application/json","path":"./_file/data/intxt_network_graph.5e0a5906.json","lastModified":1749932382069,"size":8923});
registerFile("./data/intxts_full.json", {"name":"./data/intxts_full.json","mimeType":"application/json","path":"./_file/data/intxts_full.45032677.json","lastModified":1749932381976,"size":38851});
registerFile("./data/meters.json", {"name":"./data/meters.json","mimeType":"application/json","path":"./_file/data/meters.bf657056.json","lastModified":1749932381071,"size":10007});
registerFile("./data/nodegoat_data.json", {"name":"./data/nodegoat_data.json","mimeType":"application/json","path":"./_file/data/nodegoat_data.cf632694.json","lastModified":1749932382221,"size":776050});
registerFile("./data/nodegoat_tables.json", {"name":"./data/nodegoat_tables.json","mimeType":"application/json","path":"./_file/data/nodegoat_tables.ac1e082b.json","lastModified":1749932381085,"size":91139});
registerFile("./data/sample_csv_loader.csv", {"name":"./data/sample_csv_loader.csv","mimeType":"text/csv","path":"./_file/data/sample_csv_loader.d272f4a2.csv","lastModified":1749932382633,"size":167});
registerFile("./data/sankey_data.json", {"name":"./data/sankey_data.json","mimeType":"application/json","path":"./_file/data/sankey_data.d0294715.json","lastModified":1749932382167,"size":9870});

define({id: "2934ea29", inputs: ["FileAttachment"], outputs: ["nodegoatModel"], body: (FileAttachment) => {
// Attach extracted nodegoat objects (final output of Python data loader)
const nodegoatModel = FileAttachment("./data/nodegoat_data.json").json()
return {nodegoatModel};
}});

define({id: "943ba4bb", inputs: ["FileAttachment"], outputs: ["nodegoatTables"], body: (FileAttachment) => {
// Attach restructured tables for querying
const nodegoatTables = FileAttachment("./data/nodegoat_tables.json").json()
return {nodegoatTables};
}});

define({id: "a72bc13f", inputs: ["FileAttachment"], outputs: ["meters"], body: (FileAttachment) => {
// Attach meters table for querying.
const meters = FileAttachment("./data/meters.json").json()
return {meters};
}});

define({id: "1b56572f", inputs: ["FileAttachment"], outputs: ["intertextsTable"], body: (FileAttachment) => {
// Attach full list of intertexts (used for network)
const intertextsTable = FileAttachment("./data/intxts_full.json").json()
return {intertextsTable};
}});

define({id: "f452e7ce", inputs: ["FileAttachment"], outputs: ["graphData"], body: (FileAttachment) => {
// Attach networkx graph json
const graphData = FileAttachment("./data/intxt_network_graph.json").json()
return {graphData};
}});

define({id: "8989f40c", inputs: ["FileAttachment"], outputs: ["sankeyData"], body: (FileAttachment) => {
// Attach sankey chart data
const sankeyData = FileAttachment("./data/sankey_data.json").json()
return {sankeyData};
}});

define({id: "5d380160", inputs: ["nodegoatTables"], outputs: ["lookupIDTable"], body: (nodegoatTables) => {
const lookupIDTable = new Map();

for (let i in nodegoatTables.word_instance_table) {
	let item = nodegoatTables.word_instance_table[i];
	let key = item.obj_id;
	let word = item.word;
	let line = item.line_num;
	let def = {'word': word, 'lineNum': line};
	lookupIDTable.set(key, def);
}

for (let i in nodegoatTables.author_table) {
	let item = nodegoatTables.author_table[i];
	let key = item.obj_id;
	let def = item.author_name;
	lookupIDTable.set(key, def);
}

// I may want to change this to a dictionary that includes author as well as title
for (let i in nodegoatTables.work_table) {
	let item = nodegoatTables.work_table[i];
	let key = item.obj_id;
	let def = item.title;
	lookupIDTable.set(key, def);
}
return {lookupIDTable};
}});

define({id: "e165ccd7", inputs: ["nodegoatTables","lookupIDTable"], body: (nodegoatTables,lookupIDTable) => {
for (let i in nodegoatTables.work_seg_table) {
	let item = nodegoatTables.work_seg_table[i];
	let section = item.work_section || '';
	let subsec = item.work_subsection || '';
	let key = item.obj_id;
	let work_id = String(item.work_id);
	let work = lookupIDTable.get(work_id);
	let section_string;
	if (section && subsec) {
		section_string = `${section}, ${subsec}`;
	} else if (section) {
		section_string = `${section}`;
	} else {
		section_string = '';
	}
	let def = {'work': work, 'section': section_string};
	lookupIDTable.set(key, def);
}
}});

define({id: "e56762c4", inputs: ["nodegoatTables","Inputs","view"], outputs: ["authorList","authorTable","authorPicker","authorID"], body: (nodegoatTables,Inputs,view) => {
// Create authors dropdown

const authorList = [];
const authorTable = nodegoatTables.author_table;

/* If there are any surviving bilingual poets, there may need to be a second filtering step at the works table. */

for (let author in authorTable) {
	if (authorTable[author].language === "Latin") {
		const authorSet = [authorTable[author].author_name, authorTable[author].obj_id];
		authorList.push(authorSet);
	}
}

const authorPicker = Inputs.select(new Map([[null,null]].concat(authorList)), {label: "Select author:", value: null, sort: true});
const authorID = view(authorPicker);
return {authorList,authorTable,authorPicker,authorID};
}});

define({id: "0dea0a2d", inputs: ["nodegoatTables","authorID","Inputs","view"], outputs: ["workList","workTable","workPicker","workID"], body: (nodegoatTables,authorID,Inputs,view) => {
// Create works dropdown

const workList = [];
const workTable = nodegoatTables.work_table;

for (let work in workTable) {
	if (workTable[work].author_id === authorID) {
		const workSet = [workTable[work].title, workTable[work].obj_id]
		workList.push(workSet);
	}
}

const workPicker = Inputs.select(new Map([[null, null]].concat(workList)), {label: "Select work:", value: null, sort: true});
const workID = view(workPicker);
return {workList,workTable,workPicker,workID};
}});

define({id: "fc204ce5", inputs: ["nodegoatTables","workID","Inputs","view"], outputs: ["workSegList","workSegTable","workSegPicker","workSegID"], body: (nodegoatTables,workID,Inputs,view) => {
// Create work section dropdown

const workSegList = [];
const workSegTable = nodegoatTables.work_seg_table;

for (let workSeg in workSegTable) {
	let workSegName;
	if (!workSegTable[workSeg].work_section) {	
		workSegName = "all"
	} else if (!workSegTable[workSeg].work_subsection) {
		workSegName = workSegTable[workSeg].work_section;
	} else {
		workSegName = workSegTable[workSeg].work_section + ', ' + workSegTable[workSeg].work_subsection;
	}
	
	if (workSegTable[workSeg].work_id === workID) {
		const workSegSet = [workSegName, workSegTable[workSeg].obj_id];
		workSegList.push(workSegSet);
	}
}

const workSegPicker = Inputs.select(new Map([[null, null]].concat(workSegList)), {label: "Select work section:", value: null, sort: true});
const workSegID = view(workSegPicker);
return {workSegList,workSegTable,workSegPicker,workSegID};
}});

define({id: "356626a4", mode: "inline", inputs: ["authorPicker","display"], body: async (authorPicker,display) => {
display(await(
authorPicker
))
}});

define({id: "52898f64", mode: "inline", inputs: ["workPicker","display"], body: async (workPicker,display) => {
display(await(
workPicker
))
}});

define({id: "a3d3bccb", mode: "inline", inputs: ["workSegPicker","display"], body: async (workSegPicker,display) => {
display(await(
workSegPicker
))
}});

define({id: "aa72cec3", inputs: ["authorTable","authorID","workTable","workID","workSegTable","workSegID"], outputs: ["passageDetails"], body: (authorTable,authorID,workTable,workID,workSegTable,workSegID) => {
const passageDetails = {};

for (let author in authorTable) {
	if (authorTable[author].obj_id === authorID) {
		passageDetails.authorName = authorTable[author].author_name;
	}
}

for (let work in workTable) {
	if (workTable[work].obj_id === workID) {
		passageDetails.workTitle = workTable[work].title;
	}
}

for (let workSeg in workSegTable) {
	
	if (workSegTable[workSeg].obj_id === workSegID) {	
		let workSegName;
		if (!workSegTable[workSeg].work_subsection) {
			workSegName = workSegTable[workSeg].work_section;
		} else {
			workSegName = workSegTable[workSeg].work_section + ', ' + workSegTable[workSeg].work_subsection;
		}
		
		passageDetails.workSegName = workSegName;
	}
}
return {passageDetails};
}});

define({id: "8c0022ce", inputs: ["workSegTable","workSegID"], outputs: ["workSegVars"], body: (workSegTable,workSegID) => {
// Create necessary variables for chart display

const workSegVars = {
	workSegLineMin: 1,
	workSegLineMax: null,
	workSegMeterID: null
};

// Set variables for chart display, based on work segment chosen

for (let workSeg in workSegTable) {
	if (workSegTable[workSeg].obj_id === workSegID) {
		workSegVars.workSegLineMin = workSegTable[workSeg].first_line;
		workSegVars.workSegLineMax = workSegTable[workSeg].last_line;
		workSegVars.workSegMeterID = workSegTable[workSeg].meter_id;
		break;
	}
}

return {workSegVars};
}});

define({id: "b719c6a4", inputs: ["Inputs","workSegVars","view"], outputs: ["lineMinPicker","startLine"], body: (Inputs,workSegVars,view) => {
// Create number pickers for range of lines to display

const lineMinPicker = Inputs.number([workSegVars.workSegLineMin, workSegVars.workSegLineMax], 
									{step: 1, 
									label: "Select starting line: ", 
									value: workSegVars.workSegLineMin, 
									placeholder: workSegVars.workSegLineMin});
const startLine = view(lineMinPicker);
return {lineMinPicker,startLine};
}});

define({id: "613d60d2", inputs: ["workSegVars","Inputs","view"], outputs: ["tempMax","lineMaxPicker","endLine"], body: (workSegVars,Inputs,view) => {
let tempMax = Math.min(workSegVars.workSegLineMin + 19, Math.max(workSegVars.workSegLineMin,workSegVars.workSegLineMax))

const lineMaxPicker = Inputs.number([workSegVars.workSegLineMin, workSegVars.workSegLineMax], 
									{step: 1, 
									label: "Select ending line: ", 
//									value: workSegVars.workSegLineMin + 19, 
									value: tempMax, 
									placeholder: workSegVars.workSegLineMax});
const endLine = view(lineMaxPicker);
return {tempMax,lineMaxPicker,endLine};
}});

define({id: "d2aabe69", mode: "inline", inputs: ["lineMinPicker","display"], body: async (lineMinPicker,display) => {
display(await(
lineMinPicker
))
}});

define({id: "d7e63911", mode: "inline", inputs: ["lineMaxPicker","display"], body: async (lineMaxPicker,display) => {
display(await(
lineMaxPicker
))
}});

define({id: "daab9fbd", inputs: ["startLine","endLine"], outputs: ["lineRange"], body: (startLine,endLine) => {
// Set default numbers

const lineRange = {
	firstLine: 1,
	lastLine: function() {return this.firstLine + 20;},
}


if (startLine > 0) {
	lineRange.firstLine = startLine;
}

if (endLine >= startLine) {
	lineRange.lastLine = endLine;
} else {lineRange.lastLine = lineRange.firstLine + 0;}
return {lineRange};
}});

define({id: "ea37bcac", inputs: ["workSegVars","meters","d3"], outputs: ["meterID","positions","meterLen","linePattern","meterPosArr","linePatternArr","i"], body: (workSegVars,meters,d3) => {
// Establish metrical positions

const meterID = workSegVars.workSegMeterID;
let positions;
let meterLen;
let linePattern;

for (let meter in meters) {
	if (meters[meter].meter_id === meterID) {
		positions = meters[meter].positions;
		meterLen = meters[meter].max_line_beats;
		linePattern = meters[meter].recur_line_pattern;
	}
}

const meterPosArr = d3.range(1, meterLen+1);
let linePatternArr = d3.range(1,linePattern+1);

let i = 1;
if (linePattern === 1) {		// for stichic meters
	for (let pos in positions) {
		const posBeats = positions[pos].pos_len;
		positions[pos].gridNums = [];
		for (let j = 0; j < posBeats; j++) {
			positions[pos].gridNums.push(i);
			i += 1;
		}
	}
} else {	// for meters with stanzas or multi-line patterns
	for (let line in linePatternArr){
		let currPatternLine = linePatternArr[line];
		i = 1;
		for (let pos in positions) {
			if (positions[pos].unit_line === currPatternLine) {
				const posBeats = positions[pos].pos_len;
				positions[pos].gridNums = [];
				for (let j = 0; j < posBeats; j++) {
					positions[pos].gridNums.push(i);
					i += 1;
				}
			}
		}
	}
}

return {meterID,positions,meterLen,linePattern,meterPosArr,linePatternArr,i};
}});

define({id: "22c34cd4", inputs: ["nodegoatTables","workSegID","lineRange","d3"], outputs: ["wordInstTable","wordInstArr","wordsFiltered","lineArr"], body: (nodegoatTables,workSegID,lineRange,d3) => {
// Build word-level intertexts

const wordInstTable = nodegoatTables.word_instance_table;
const wordInstArr = [];

for (let inst in wordInstTable) {
	if (wordInstTable[inst].work_segment_id === workSegID) {
		wordInstArr.push(wordInstTable[inst])
	}
}

const wordsFiltered = wordInstArr.filter(inst => inst.line_num >= lineRange.firstLine && inst.line_num <= lineRange.lastLine);
const lineArr = d3.range(lineRange.firstLine, lineRange.lastLine+1);
return {wordInstTable,wordInstArr,wordsFiltered,lineArr};
}});

define({id: "dec282c4", inputs: ["nodegoatTables","wordsFiltered","positions","lineArr","meterPosArr"], outputs: ["wordLvlIntxts","intertextsArrComplete","intertextsArr","intxtCnts"], body: (nodegoatTables,wordsFiltered,positions,lineArr,meterPosArr) => {
// Get intertexts

const wordLvlIntxts = nodegoatTables.word_lvl_intxt_table;

if (wordsFiltered.length === 0) {wordsFiltered.push(
	{obj_id: "",
  word: "",
  lemma_id: "",
  work_segment_id: "",
  line_num: 0,
  line_num_modifier: null,
  start_pos_id: "",
  end_pos_id: ""}
)}

for (let word in wordsFiltered) {
	wordsFiltered[word].posIDs = [];
	wordsFiltered[word].directIntertexts = 0;
	wordsFiltered[word].indirectIntertexts = 0;
	wordsFiltered[word].directIntertextIDs = [];
	wordsFiltered[word].indirectIntertextIDs = [];

// Assign all spanned positions to word

	let posMatch = false;
	for (let posn in positions) {
		if (wordsFiltered[word].start_pos_id === positions[posn].meter_pos_len_id) {
			posMatch = true;
		}
		if (posMatch === true) {
			wordsFiltered[word].posIDs.push(positions[posn].meter_pos_len_id);		
		}
		if (wordsFiltered[word].end_pos_id === positions[posn].meter_pos_len_id) {
			posMatch = false;
			break;
		}
	}

// Gather direct intertexts
	
	for (let intxt in wordLvlIntxts) {
		if (wordLvlIntxts[intxt].target_word_id === wordsFiltered[word].obj_id) {	// check each intertext to see if the current word is its target
			let sourceID = wordLvlIntxts[intxt].source_word_id;		// if so, set 'sourceID' to the respective source word
			wordsFiltered[word].directIntertexts += 1;		// increment the number of direct intertexts
			wordsFiltered[word].directIntertextIDs.push(sourceID);	// add the source word to the list of direct intertexts
		}
	}

// Gather indirect intertexts based on direct intertexts

	const checkedIDs = [];
	for (let i in wordsFiltered[word].directIntertextIDs) {
		let id = wordsFiltered[word].directIntertextIDs[i];
		for (let intxt in wordLvlIntxts) {
			if (wordLvlIntxts[intxt].target_word_id === id) {		// check each intertext to see if a direct intertext source is also the target of another intertext
				let sourceID = wordLvlIntxts[intxt].source_word_id;		// if so, set 'sourceID' to the respective source word
				if (!wordsFiltered[word].indirectIntertextIDs.includes(sourceID) && !wordsFiltered[word].directIntertextIDs.includes(sourceID)) {
					wordsFiltered[word].indirectIntertextIDs.push(sourceID);	// if the relevant source word isn't already included in the direct or indirect intertexts, add it to the list of indirect intertexts
				} 
			}
		}
		checkedIDs.push(id);
	}

// Gather indirect intertexts based on indirect intertexts
	
	let j = checkedIDs.length;
	do {
	for (let i in wordsFiltered[word].indirectIntertextIDs) {
		let id = wordsFiltered[word].indirectIntertextIDs[i];
		if (!checkedIDs.includes(id)){
		for (let intxt in wordLvlIntxts) {
			if (wordLvlIntxts[intxt].target_word_id === id) {
				let sourceID = wordLvlIntxts[intxt].source_word_id;	
				if (!wordsFiltered[word].indirectIntertextIDs.includes(sourceID) && !wordsFiltered[word].directIntertextIDs.includes(sourceID)) {
					wordsFiltered[word].indirectIntertextIDs.push(sourceID);
					}
				}
			}
		}
		checkedIDs.push(id);
		j += 1;
	}} while (j < checkedIDs.length);

	wordsFiltered[word].indirectIntertexts = wordsFiltered[word].indirectIntertextIDs.length;
}
	
const intertextsArrComplete = [];

for (let line in lineArr) {
	for (let i in meterPosArr) {
		let intertextObj = {};
		intertextObj.lineNum = lineArr[line];
		intertextObj.linePos = meterPosArr[i];
		intertextObj.intxtCnt = 0;
		for (let posn in positions) {
			if (positions[posn].gridNums.includes(meterPosArr[i])) {
				intertextObj.linePosID = positions[posn].meter_pos_len_id;
				break;
			}
		}
		for (let word in wordsFiltered) {
			if (wordsFiltered[word].line_num === intertextObj.lineNum && wordsFiltered[word].posIDs.includes(intertextObj.linePosID)) {
				intertextObj.wordObj = wordsFiltered[word];
				intertextObj.intxtCnt = wordsFiltered[word].directIntertexts + wordsFiltered[word].indirectIntertexts;
				intertextObj.word = wordsFiltered[word].word;
			}
		}
		
		intertextsArrComplete.push(intertextObj);
	}
}

const intertextsArr = intertextsArrComplete.filter(pos => pos.word); // only include cells that have a word assigned to them

// Get final intertext counts, in order to set tick range

const intxtCnts = [];

if (intertextsArr.length > 0) {
	for (let i in intertextsArr) {
		intxtCnts.push(intertextsArr[i].intxtCnt);
	}
}

return {wordLvlIntxts,intertextsArrComplete,intertextsArr,intxtCnts};
}});

define({id: "c64503e1", inputs: ["meters","meterID","lineRange"], outputs: ["gridX","gridY","cellSize","gridHeight","gridWidth"], body: (meters,meterID,lineRange) => {
// Define grid width based on the selection's meter.

let gridX;

for (let meter in meters) {
	if (meters[meter].meter_id === meterID) {
		gridX = meters[meter].max_line_beats
	}
}

// Define grid height based on number of lines.

const gridY = (lineRange.lastLine - lineRange.firstLine) + 1;  // I may need to modify this to accomodate passages with extra lines

const cellSize = 20;
const gridHeight = gridY * cellSize;
const gridWidth = gridX * cellSize;
return {gridX,gridY,cellSize,gridHeight,gridWidth};
}});

define({id: "ddc7f23c", inputs: ["intertextsArr","Plot","d3","gridX","lineRange","intxtCnts","gridWidth","gridHeight"], outputs: ["plotDisplay"], body: (intertextsArr,Plot,d3,gridX,lineRange,intxtCnts,gridWidth,gridHeight) => {
// Create plot, conditional on the existence of intertexts

const plotDisplay = intertextsArr.every(intxt => intxt.intxtCnt === 0) ? null : Plot.plot({
	grid: true,
	x: {
		label: null, 
		domain: d3.range(1,gridX+1),
		padding: 0,
		axis: null,
		},
	y: {
		label: 'Line', 
		domain: d3.range(lineRange.firstLine, lineRange.lastLine +1),
		tickSize: 0,
		},
	color: {scheme: "Greens", 
		legend: true, 
		label: "Total Intertexts (direct & indirect)",
		ticks: d3.range(Math.min(...intxtCnts), Math.max(...intxtCnts)+1),
		tickFormat: d => Math.floor(d),
		},
	marks: [
		Plot.cell(intertextsArr, {
			x: "linePos",
			y: "lineNum",
			fill: d => d.wordObj.directIntertexts + d.wordObj.indirectIntertexts,
			tip: {format: {
				word: true,
				x: false,
				y: false,
				lineNum: true,
				fill: false
			}},
			channels: {
				title: d => `${d.wordObj.word} (line ${d.lineNum})\n# direct intertexts: ${d.wordObj.directIntertexts}\n# indirect intertexts: ${d.wordObj.indirectIntertexts}`,
				word: d => d.wordObj.word,
				lineNum: {
					value: "lineNum",
					label: "line"
				},
				dirIntxt: {
					value: d => d.wordObj.directIntertexts,
					label: "# direct intertexts"
				},
				indIntxt: {
					value: d => d.wordObj.indirectIntertexts,
					label: "# inherited intertexts"
				},
			},
		})
	],
	style: {fontSize: "12pt"},
	width: gridWidth + 120,
	height: gridHeight + 50,
	marginTop: 20,
	marginRight: 50,
	marginBottom: 30,
	marginLeft: 70
});

return {plotDisplay};
}});

define({id: "27166e2c", inputs: ["plotDisplay","Generators"], outputs: ["plotCurrSelect"], body: (plotDisplay,Generators) => {
const plotCurrSelect = !plotDisplay ? null : Generators.input(plotDisplay);
return {plotCurrSelect};
}});

define({id: "11066ec5", inputs: ["plotDisplay","display","html","passageDetails","lineRange","plotCurrSelect"], outputs: ["bgColor"], body: (plotDisplay,display,html,passageDetails,lineRange,plotCurrSelect) => {
let bgColor = "#ccccff"; // this is a nice blue that works well
/* the following are attempts to make a more "papyrus"-like background that still contrasts with the lightest green */
/*
bgColor = "#ddcc88";
bgColor = "#daba91"; // taken from an actual papyrus pixel
bgColor = "#ccaf87"; // taken from an actual papyrus pixel
bgColor = "#d4b48c"; // average of the previous two colors
*/

if (!plotDisplay) {
	display(html`<p>Based on information currently in the database, there are no intertexts in the specified passage.</p>`)
} else {

display(

html`<p style="max-width:none; font-size:smaller;">Click on a cell to freeze the popup information. <b>Direct intertexts</b> are those where a scholar has suggested a direct link between the present word and a word in an earlier text. <b>Indirect intertexts</b> are intertexts at further remove (i.e., where a direct or indirect intertext refers to another, still earlier, passage). Currently, the project does not include intratexts (allusions to other passages within the same text).</p>

<p style="max-width:none; font-size:smaller;"><b>Two caveats:</b> absence of a word does not necessarily mean that there are no intertexts, just that they are not yet in the database; and lines appear in numeric order, even if editors agree that they should be transposed.</p></div>

<div class="grid grid-cols-2"><div class="card" style="background-color:${bgColor}; padding-top: 30px;">

<h2 style="padding-bottom: 10px;">${passageDetails.authorName}, <i>${passageDetails.workTitle}</i>, ${passageDetails.workSegName}: lines ${lineRange.firstLine}&ndash;${lineRange.lastLine}</h2>

${plotDisplay}
</div>
<div>
	<p>Eventually there will be a network visualization in this space. For now, you can see <a href="./sankey">a diagram of the full set of available intertexts</a> to get a sense of what that visualization might look like.</p>
	<p><i>The following information will eventually not be displayed.</i></p>
	<p>Selected word object ID: ${plotCurrSelect ? plotCurrSelect.wordObj.obj_id : "none"}<br>
	Selected word: ${plotCurrSelect ? plotCurrSelect.word : "none"}</p>
</div>
</div>`
)}

return {bgColor};
}});

define({id: "89f56fce", inputs: ["plotDisplay","display","html","plotCurrSelect"], body: (plotDisplay,display,html,plotCurrSelect) => {
if (!plotDisplay) {display(html`<p></p>`)}
else {
	display(html`<p>The selected datapoint, which will serve as the starting point of the generated network (this will eventually not be displayed):</p>`)
	if (plotCurrSelect) {display(plotCurrSelect)} else {display(html`<p><i>No current selection in plot.</i></p>`)}
	}
}});

define({id: "7e75896d", inputs: ["nodegoatModel","display"], body: async (nodegoatModel,display) => {
display(await(
nodegoatModel
))
}});

define({id: "ba829522", inputs: ["nodegoatTables","display"], body: async (nodegoatTables,display) => {
display(await(
nodegoatTables
))
}});

define({id: "c8e489e2", inputs: ["meters","display"], body: async (meters,display) => {
display(await(
meters
))
}});

define({id: "26eb7b8e", inputs: ["intertextsTable","display"], body: async (intertextsTable,display) => {
display(await(
intertextsTable
))
}});

define({id: "7e75896d-1", inputs: ["nodegoatModel","display"], body: async (nodegoatModel,display) => {
display(await(
nodegoatModel
))
}});

define({id: "ba829522-1", inputs: ["nodegoatTables","display"], body: async (nodegoatTables,display) => {
display(await(
nodegoatTables
))
}});

define({id: "af7d285a", inputs: ["positions","display"], body: async (positions,display) => {
display(await(
positions
))
}});

define({id: "0bc44f84", inputs: ["wordsFiltered","display"], body: async (wordsFiltered,display) => {
display(await(
wordsFiltered
))
}});

define({id: "26d98358", inputs: ["intertextsArr","display"], body: async (intertextsArr,display) => {
display(await(
intertextsArr
))
}});

define({id: "c8e489e2-1", inputs: ["meters","display"], body: async (meters,display) => {
display(await(
meters
))
}});

define({id: "336a3002", inputs: ["graphData","display"], body: async (graphData,display) => {
display(await(
graphData
))
}});

define({id: "7720804a", inputs: ["sankeyData","display"], body: async (sankeyData,display) => {
display(await(
sankeyData
))
}});

define({id: "9154341a", inputs: ["lookupIDTable","display"], body: async (lookupIDTable,display) => {
display(await(
lookupIDTable
))
}});

define({id: "b109a32d", inputs: ["csvSamp","display"], body: async (csvSamp,display) => {
display(await(
csvSamp
))
}});

define({id: "655fc79e", inputs: ["csvSamp","view","Inputs"], outputs: ["workArr","work"], body: (csvSamp,view,Inputs) => {
const workArr = [];
for (let item in csvSamp) {
	if (item !== 'columns') {
		let work = csvSamp[item].work
		if (!workArr.includes(work)) {
			workArr.push(work);
		}
	}
};
const work = view(Inputs.select([null].concat(workArr), {label: "Work"}))
return {workArr,work};
}});

define({id: "00e13ed7", mode: "inline", inputs: ["work","display"], body: async (work,display) => {
display(await(
work
))
}});

define({id: "c7bcee9d", inputs: ["csvSamp"], outputs: ["csvItems"], body: (csvSamp) => {
const csvItems = [];
for (let item in csvSamp) {
	csvItems.push(item);
}
return {csvItems};
}});

define({id: "7ab11a40", inputs: ["csvItems","display"], body: async (csvItems,display) => {
display(await(
csvItems
))
}});

define({id: "bbec1926", inputs: ["FileAttachment"], outputs: ["csvSamp"], body: (FileAttachment) => {
const csvSamp = FileAttachment("./data/sample_csv_loader.csv").csv({typed: true})
return {csvSamp};
}});

define({id: "215c8dbb", inputs: ["Inputs","csvSamp","display"], body: async (Inputs,csvSamp,display) => {
display(await(
Inputs.table(csvSamp)
))
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link observablehq-link-active"><a href="./">Visualizing Intertextuality</a></li>
  </ol>
  <ol>
    <li class="observablehq-link"><a href="./about">About the Project</a></li>
    <li class="observablehq-link"><a href="./sankey">Full Intertext Diagram</a></li>
    <li class="observablehq-link"><a href="./thanks">Thanks and Acknowledgements</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),o=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?o.checked=r==="true":o.indeterminate=!0;for(const t of document.querySelectorAll("#observablehq-sidebar summary")){const s=t.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${t.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<main id="observablehq-main" class="observablehq">
<h1 id="visualizing-intertextuality" tabindex="-1"><a class="observablehq-header-anchor" href="#visualizing-intertextuality">Visualizing Intertextuality</a></h1>
<p><strong>Developed by:</strong> <a href="http://www.darcykrasne.com/" target="_blank" rel="noopener noreferrer">Darcy Krasne</a></p>
<p>A project to visualize intertexts in Latin poetry using <a href="https://nodegoat.net/" target="_blank" rel="noopener noreferrer">nodegoat</a>, <a href="https://observablehq.com/framework/" target="_blank" rel="noopener noreferrer">Observable Framework</a>, and Python. (See <a href="./about">the about page</a> for further details.)</p>
<p>View the code on <a href="https://github.com/dkrasne/visualizing_intertextuality" target="_blank" rel="noopener noreferrer">GitHub</a>.</p>
<!-- Load data -->
<div class="observablehq observablehq--block"><!--:2934ea29:--></div>
<div class="observablehq observablehq--block"><!--:943ba4bb:--></div>
<div class="observablehq observablehq--block"><!--:a72bc13f:--></div>
<div class="observablehq observablehq--block"><!--:1b56572f:--></div>
<div class="observablehq observablehq--block"><!--:f452e7ce:--></div>
<div class="observablehq observablehq--block"><!--:8989f40c:--></div>
<!-- End load data -->
<!-- Create mapping of ID-to-name -->
<div class="observablehq observablehq--block"><!--:5d380160:--></div>
<div class="observablehq observablehq--block"><!--:e165ccd7:--></div>
<!-- End mapping -->
<h2 id="select-passage-to-view" tabindex="-1"><a class="observablehq-header-anchor" href="#select-passage-to-view">Select passage to view</a></h2>
<div class="tip">Currently there is a limited set of intertexts in the database. Choose Valerius Flaccus, <i>Argonautica</i>, Book 1, lines 1–4 or Book 2, lines 475–476 to see what the display looks like. You can also <a href="./sankey">view this diagram</a> to get a rough idea of what the full network of intertexts currently looks like.</div>
<div class="observablehq observablehq--block"><!--:e56762c4:--></div>
<div class="observablehq observablehq--block"><!--:0dea0a2d:--></div>
<div class="observablehq observablehq--block"><!--:fc204ce5:--></div>
<div class="grid grid-cols-3">
	<div class="card">
		<observablehq-loading></observablehq-loading><!--:356626a4:-->
	</div>
	<div class="card">
		<observablehq-loading></observablehq-loading><!--:52898f64:-->
	</div>
	<div class="card">
		<observablehq-loading></observablehq-loading><!--:a3d3bccb:-->
	</div>
</div>
<div class="observablehq observablehq--block"><!--:aa72cec3:--></div>
<div class="observablehq observablehq--block"><!--:8c0022ce:--></div>
<div class="observablehq observablehq--block"><!--:b719c6a4:--></div>
<div class="observablehq observablehq--block"><!--:613d60d2:--></div>
<div class="grid grid-cols-2">
<div class="card">
<observablehq-loading></observablehq-loading><!--:d2aabe69:-->
</div>
<div class="card">
<observablehq-loading></observablehq-loading><!--:d7e63911:-->
</div>
</div>
<div class="observablehq observablehq--block"><!--:daab9fbd:--></div>
<div class="observablehq observablehq--block"><!--:ea37bcac:--></div>
<!-- Prepare intertexts for display -->
<div class="observablehq observablehq--block"><!--:22c34cd4:--></div>
<div class="observablehq observablehq--block"><!--:dec282c4:--></div>
<h2 id="visualization" tabindex="-1"><a class="observablehq-header-anchor" href="#visualization">Visualization</a></h2>
<!-- Create grid -->
<div class="observablehq observablehq--block"><!--:c64503e1:--></div>
<!--
The grid will be ${gridX} cells wide.
The grid will be ${gridY} cells tall.
-->
<div class="observablehq observablehq--block"><!--:ddc7f23c:--></div>
<div class="observablehq observablehq--block"><!--:27166e2c:--></div>
<div class="observablehq observablehq--block"><!--:11066ec5:--></div>
<div class="observablehq observablehq--block"><!--:89f56fce:--></div>
<hr>
<!--

## Attempting network

```js
const width = 640;
const height = 640;

const links = graphData.links.map((d) => Object.create(d));
const nodes = graphData.nodes.map((d) => Object.create(d));

const color = d3.scaleOrdinal(d3.schemeObservable10);

const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id((d) => d.id))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto;");


// a combination of ChatGPT and Elijah Meeks
const marker = svg.append("defs")
	.append("marker")
  .attr("id", "arrow")
  .attr("viewBox", "0 0 10 10")
  .attr("refX", 20)
  .attr("refY", 5)
  .attr("markerUnits", 'userSpaceOnUse')
  .attr("markerWidth", 6)
  .attr("markerHeight", 6)
  .attr("orient", "auto")
  .append("path")
  .attr("d", "M 0 0 L 10 5 L 0 10 z")
  .attr("fill", "black")
  .attr("fill-opacity", 0.6);

const link = svg.append("g")
    .attr("stroke", "var(--theme-foreground-faint)")
    .attr("stroke-opacity", 0.6)
  .selectAll("line")
  .data(links)
  .join("line")
    .attr("stroke-width", (d) => Math.sqrt(d.weight))
	.attr("marker-end", "url(#arrow)");

const node = svg.append("g")
    .attr("stroke", "var(--theme-background)")
    .attr("stroke-width", 1.5)
  .selectAll("circle")
  .data(nodes)
  .join("circle")
    .attr("r", (d) => {
    let proto = Object.getPrototypeOf(d);
	let numProps = Object.keys(proto).length - 2;
    return Math.sqrt(numProps) * 5})
    .attr("fill", (d) => color(d.author))
    .call(drag(simulation));

node.append("title")
    .text((d) => lookupIDTable.get(d.id).section ? `${lookupIDTable.get(d.id).work}, ${lookupIDTable.get(d.id).section}` : lookupIDTable.get(d.id).work);

function ticked() {
  link
      .attr("x1", (d) => d.source.x)
      .attr("y1", (d) => d.source.y)
      .attr("x2", (d) => d.target.x)
      .attr("y2", (d) => d.target.y);

  node
      .attr("cx", (d) => d.x)
      .attr("cy", (d) => d.y);
}

display(svg.node());
```

```js
function drag(simulation) {

  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
}
```
```js
nodes
```
```js
links
```


```js
// Create maps to store total counts and assign indices for each source-target pair.
const edgeCountMap = new Map();
const edgeIndexMap = new Map();

// Loop through links to annotate them.
graphData.links.forEach(link => {
  // Assume link.source and link.target are objects with an "id" property.
  const key = `${link.source.id}-${link.target.id}`;
  // Get the current index for this pair (starting at 0).
  const currentIndex = edgeIndexMap.get(key) || 0;
  // Assign this edge its index.
  link.edgeIndex = currentIndex;
  // Update the index for the next edge.
  edgeIndexMap.set(key, currentIndex + 1);
  // Also count the total number of edges for this pair.
  edgeCountMap.set(key, (edgeCountMap.get(key) || 0) + 1);
});

// (Optional) Log the edge counts to verify.
// console.log("Edge counts:", [...edgeCountMap.entries()]);

```

```js

const links2 = graphData.links.map((d) => Object.create(d));
const nodes2 = graphData.nodes.map((d) => Object.create(d));


const svg2 = html`<svg width=800 height=600 style="border:1px solid black"><defs></defs></svg>`;

const simulation2 = d3.forceSimulation(nodes2)
    .force("link", d3.forceLink(links2).id((d) => d.id))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2))

const selection = d3.select(svg2);

// Define a small offset to prevent overlap (adjust as needed)
const linkOffset = 3;
const curveStrength = 30; // Adjust curve height

// Find min/max values in your node positions
const xExtent = d3.extent(nodes2, d => d.x);
const yExtent = d3.extent(nodes2, d => d.y);

// Create scaling functions to map node positions to canvas size
const xScale = d3.scaleLinear().domain(xExtent).range([50, 750]); // Keep some margin
const yScale = d3.scaleLinear().domain(yExtent).range([50, 550]);

d3.select(svg2)
  .selectAll("path")
  .data(links2)
  .join("path")
  .attr("d", d => {
    const x1 = xScale(d.source.x);
    const y1 = yScale(d.source.y);
    const x2 = xScale(d.target.x);
    const y2 = yScale(d.target.y);
    
    const key = `${d.source.id}-${d.target.id}`;
    const totalEdges = edgeCountMap.get(key); // Total edges for this pair
    const index = d.edgeIndex;               // This edge's index
    
    // Calculate curve offset.
    // The formula centers the edges: if there is an odd number, the middle edge is straight;
    // if even, they are symmetrically curved.
    const curveOffset = ((index + 1) - (totalEdges + 1) / 2) * curveStrength;
    
    // Compute midpoint for the quadratic Bézier curve.
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2 - curveOffset;
    
    return `M ${x1},${y1} Q ${midX},${midY} ${x2},${y2}`;
  })
  .attr("fill", "none")
  .attr("stroke", "black")
  .attr("stroke-width", 1);

/* 
// Apply scaling when setting positions
// Draw offset links (edges)
selection
  .selectAll("line")
  .data(graphData.links)
  .join("line")
  .attr("x1", d => xScale(d.source.x) + (d.key ? linkOffset * (d.key % 2 ? 1 : -1) : 0))
  .attr("y1", d => yScale(d.source.y) + (d.key ? linkOffset * (d.key % 2 ? -1 : 1) : 0))
  .attr("x2", d => xScale(d.target.x) + (d.key ? linkOffset * (d.key % 2 ? -1 : 1) : 0))
  .attr("y2", d => yScale(d.target.y) + (d.key ? linkOffset * (d.key % 2 ? 1 : -1) : 0))
  .attr("stroke", "black")
  .attr("stroke-width", 1);
*/

// Draw nodes (circles)
selection
  .selectAll("circle")
  .data(nodes2)
  .join("circle")
  .attr("cx", d => xScale(d.x))
  .attr("cy", d => yScale(d.y))
  .attr("r", 5)
  .attr("fill", "black");




const defs = d3.select(svg2).select("defs");

defs.append("marker")
  .attr("id", "arrow")
  .attr("viewBox", "0 0 10 10")
  .attr("refX", 20)
  .attr("refY", 5)
  .attr("markerWidth", 6)
  .attr("markerHeight", 6)
  .attr("orient", "auto")
  .append("path")
  .attr("d", "M 0 0 L 10 5 L 0 10 z")
  .attr("fill", "black");

// Now, update the edges to use the arrowheads
d3.select(svg2)
  .selectAll("path")
  .attr("marker-end", "url(#arrow)");


```

```js
view(svg2)
```

-->
<hr>
<h2 id="data" tabindex="-1"><a class="observablehq-header-anchor" href="#data">Data</a></h2>
<details>
<summary>Click here to view the full data.</summary>
<p>Raw data from nodegoat (extracted into separate objects):</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:7e75896d:--></div>
<p>Data after initial transformation:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:ba829522:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:c8e489e2:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:26eb7b8e:--></div>
</details>
<hr>
<h1 id="sandbox" tabindex="-1"><a class="observablehq-header-anchor" href="#sandbox">Sandbox</a></h1>
<p>Everything below here will not be in the final project.</p>
<h2 id="data-checks" tabindex="-1"><a class="observablehq-header-anchor" href="#data-checks">Data Checks</a></h2>
<p><code>nodegoatModel</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:7e75896d-1:--></div>
<p><code>nodegoatTables</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:ba829522-1:--></div>
<p><code>positions</code> (metrical positions):</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:af7d285a:--></div>
<p><code>wordsFiltered</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:0bc44f84:--></div>
<p><code>intertextsArr</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:26d98358:--></div>
<p>Meters:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:c8e489e2-1:--></div>
<p><code>graphData</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:336a3002:--></div>
<p><code>sankeyData</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:7720804a:--></div>
<p><code>lookupIDTable</code>:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:9154341a:--></div>
<hr>
<h2 id="testing-stuff-goes-below-here" tabindex="-1"><a class="observablehq-header-anchor" href="#testing-stuff-goes-below-here">Testing stuff goes below here.</a></h2>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:b109a32d:--></div>
<div class="observablehq observablehq--block"><!--:655fc79e:--></div>
<p>The selected work is <em><observablehq-loading></observablehq-loading><!--:00e13ed7:--></em>.</p>
<!-- Some information on Framework's reactivity: https://medium.com/@stxmendez/how-observable-implements-reactive-programming-784bcc02382d -->
<div class="observablehq observablehq--block"><!--:c7bcee9d:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:7ab11a40:--></div>
<pre><code>let lineMin;
let lineMax;

lineMin = 1; // this will actually need to change depending on the range of the selection
lineMax = 10; // this will actually need to change depending on the range of the selection

const lineRange = [];

for (let i = lineMin; i &lt;= lineMax; i++) {
	lineRange.push(i);
}
</code></pre>
<pre><code>lineRange
</code></pre>
<pre><code>const numX = workArr.length; // this will actually be determined by the appropriate length for a given meter
const numY = lineRange.length;
const cellSize = 20;
const gridHeight = numY * cellSize;
const gridWidth = numX * cellSize;
</code></pre>
<pre><code>Plot.plot({
	color: {scheme: "Blues", legend: true},
	marks: [
		Plot.cell(
			csvSamp,
			Plot.group(
				{fill: "count"},
				{
					x: "work",
					y: "line",
					fill: "word",
//					filter: (d) =&gt; d.line &gt;= lineMin &amp;&amp; d.line &lt;= lineMax &amp;&amp; d.work === work,
					filter: null,
					tip: true // Info on customizing tooltip using 'format': https://observablehq.com/plot/marks/tip
				}
			)
		),
//		Plot.axisY({ticks: []}),
	],
	x: {
		padding: 0, 
		axis: "both",  // set to null for no axis
		tickRotate: -30,
//		label: null  // use this to remove the label for the axis
	},
	y: {
		padding: 0, 
		domain: d3.range(lineMin, lineMax + 1),
		tickSize: 0
	},
	width: gridWidth + 100,
	height: gridHeight + 100,
	marginTop: 50,
	marginRight: 50,
	marginBottom: 50,
	marginLeft: 50
})
</code></pre>
<div class="observablehq observablehq--block"><!--:bbec1926:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:215c8dbb:--></div>
</main>
<footer id="observablehq-footer">
<nav><a rel="next" href="./about"><span>About the Project</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2025-06-14T20:19:21">Jun 14, 2025</a>.</div>
</footer>
</div>
</body>
</html>
